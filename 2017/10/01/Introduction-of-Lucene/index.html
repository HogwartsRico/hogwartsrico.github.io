<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.6 -->
    <script>
        window.materialVersion = "1.5.6"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0',
            '1.5.2',
            '1.5.5'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">









    <link rel="dns-prefetch" href="https://fonts.googleapis.com">





    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            Lucene入门 | 
        
        Rico&#39;s Blog
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no">
    <meta name="description" itemprop="description" content>
    <meta name="keywords" content="HogwartsRico">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?NKhlKQkXw/c66TR5p4wO+w==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/github-v2.min.css?AfzKxt++K+/lhZBlSjnxwg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body {
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text {
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Rico&#39;s Blog">
    <meta name="msapplication-starturl" content="http://hogwartsrico.github.io/2017/10/01/Introduction-of-Lucene/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Rico&#39;s Blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://hogwartsrico.github.io/2017/10/01/Introduction-of-Lucene/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Lucene入门 | Rico&#39;s Blog">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content>
    

    
        <meta property="article:published_time" content="Sun Oct 01 2017 21:19:42 GMT+0800">
        <meta property="article:modified_time" content="Tue Mar 24 2020 11:19:16 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://hogwartsrico.github.io/2017/10/01/Introduction-of-Lucene/index.html">
    

    <!-- Structured-data for SEO -->
    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span id="MD-burger-id" class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Lucene简介和创建索引初步"><span class="post-toc-number">1.</span> <span class="post-toc-text">Lucene简介和创建索引初步</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#搜索初步"><span class="post-toc-number">2.</span> <span class="post-toc-text">搜索初步</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#索引创建-域选项"><span class="post-toc-number">3.</span> <span class="post-toc-text">索引创建  域选项</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#存储域选项"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">存储域选项</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#索引域选项"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">索引域选项</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#索引的删除和更新"><span class="post-toc-number">4.</span> <span class="post-toc-text">索引的删除和更新</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#删除"><span class="post-toc-number">4.0.1.</span> <span class="post-toc-text">删除</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#更新"><span class="post-toc-number">4.0.2.</span> <span class="post-toc-text">更新</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#索引加权操作"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">索引加权操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#使用Luke工具查看索引"><span class="post-toc-number">5.</span> <span class="post-toc-text">使用Luke工具查看索引</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#对时间和日期进行索引"><span class="post-toc-number">6.</span> <span class="post-toc-text">对时间和日期进行索引</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#IndexReader的设计"><span class="post-toc-number">7.</span> <span class="post-toc-text">IndexReader的设计</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#使用reader进行删除"><span class="post-toc-number">8.</span> <span class="post-toc-text">使用reader进行删除</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Directory的几种操作方式"><span class="post-toc-number">9.</span> <span class="post-toc-text">Directory的几种操作方式</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TermRange等基本操作"><span class="post-toc-number">10.</span> <span class="post-toc-text">TermRange等基本操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#精确查询"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">精确查询</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#范围查询"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">范围查询</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数字范围查询"><span class="post-toc-number">10.3.</span> <span class="post-toc-text">数字范围查询</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#其他常用Query查询"><span class="post-toc-number">11.</span> <span class="post-toc-text">其他常用Query查询</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前缀匹配搜索"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">前缀匹配搜索</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#通配符搜索"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">通配符搜索</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#booleanQuery-连接多个子查询"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">booleanQuery 连接多个子查询</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PhraseQuery-短语查询"><span class="post-toc-number">11.4.</span> <span class="post-toc-text">PhraseQuery 短语查询</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#fuzzyQuery-模糊查询"><span class="post-toc-number">11.5.</span> <span class="post-toc-text">fuzzyQuery 模糊查询</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#QueryParse"><span class="post-toc-number">12.</span> <span class="post-toc-text">QueryParse</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#分页搜索"><span class="post-toc-number">13.</span> <span class="post-toc-text">分页搜索</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#再查询的方式"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">再查询的方式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SearchAfter的方式"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">SearchAfter的方式</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#分词器的原理"><span class="post-toc-number">14.</span> <span class="post-toc-text">分词器的原理</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#通过TokenStream显示分词"><span class="post-toc-number">15.</span> <span class="post-toc-text">通过TokenStream显示分词</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#通过TokenStream显示分词的详细信息"><span class="post-toc-number">16.</span> <span class="post-toc-text">通过TokenStream显示分词的详细信息</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#自定义分词器"><span class="post-toc-number">17.</span> <span class="post-toc-text">自定义分词器</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#中文分词介绍"><span class="post-toc-number">18.</span> <span class="post-toc-text">中文分词介绍</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#实现自定义同义词分词器"><span class="post-toc-number">19.</span> <span class="post-toc-text">实现自定义同义词分词器</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#自定义排序"><span class="post-toc-number">20.</span> <span class="post-toc-text">自定义排序</span></a></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 34 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                Lucene入门
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Rico</strong>
        <span>10月 01, 2017</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=Lucene入门&url=http://hogwartsrico.github.io/2017/10/01/Introduction-of-Lucene/index.html&pic=http://hogwartsrico.github.io/img/favicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=Lucene入门&url=http://hogwartsrico.github.io/2017/10/01/Introduction-of-Lucene/index.html&via=Rico" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://hogwartsrico.github.io/2017/10/01/Introduction-of-Lucene/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="Lucene简介和创建索引初步"><a href="#Lucene简介和创建索引初步" class="headerlink" title="Lucene简介和创建索引初步"></a>Lucene简介和创建索引初步</h1><p>在全文索引工具中，都是由这三部分组成 </p>
<ol>
<li>索引部分</li>
<li>分词部分</li>
<li>搜索部分  </li>
</ol>
<p>HelloLucene.java</p>
<pre><code class="Java">public class HelloLucene {
    /**
     * 建立索引
     */
    public void createIndex() {
        //1. 创建Directory    索引存放位置：硬盘,内存
        //Directory directory=new RAMDirectory();//索引建在内存中
        Directory directory= null;
        try {
            directory = FSDirectory.open(new File(&quot;/Users/xxx/workspace/LuceneDemo/hellolucene/index&quot;));
        } catch (IOException e) {
            e.printStackTrace();
        }
        //2. 创建IndexWriter  通过IndexWriter来写我们的索引
        IndexWriterConfig indexWriterConfig=new IndexWriterConfig(Version.LUCENE_35,new StandardAnalyzer(Version.LUCENE_35));//第一个参数是需要匹配的版本在2.9之后，Lucene不是全部兼容的了,第二个参数时分词器，我们这里创建了一个标准的分词器,里面也需要传入版本号
        IndexWriter indexWriter=null;
        try {
            //3.5版本之前的Lucene创建IndexWriter是这样的
            //new IndexWriter(Directory d路径, Analyzer a分词器,boolean create是否每次都是重新创建索引 false会在原来的后面追加,MaxFieldLength mfl Filed域最大值)
            indexWriter=new IndexWriter(directory,indexWriterConfig);
            //3. 创建Document对象 (里面有标题，文档大小，文档路径，文档内容等等)
            Document doc=null;
            File docDir=new File(&quot;/Users/xxx/workspace/LuceneDemo/hellolucene/doc&quot;);
            for(File file:docDir.listFiles()){
                //3. 创建Document对象 (里面有标题，文档大小，文档路径，文档内容等等)
                doc=new Document();
                //4. 为Document添加Field
                doc.add(new Field(&quot;content&quot;,new FileReader(file)));//内容 通过filereader读进来的内容默认是不存储的 如果要存储，需要把文件的内容转成字符串然后和下面的一样添加  
                doc.add(new Field(&quot;filename&quot;,file.getName(),Field.Store.YES,Field.Index.NOT_ANALYZED));//把文件名存储到硬盘中,文件名不需要分词
                doc.add(new Field(&quot;path&quot;,file.getAbsolutePath(),Field.Store.YES,Field.Index.NOT_ANALYZED));//需要存储，也不需要分词
                //5. 通过IndexWriter添加文档到索引中
                indexWriter.addDocument(doc);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {//indexWriter必须关闭
            if(indexWriter!=null){
                try {
                    indexWriter.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<p>HelloLuceneTest.java</p>
<pre><code class="Java">package com.hikvison;

import org.junit.Test;

public class HelloLuceneTest {
    HelloLucene helloLucene=new HelloLucene();

    @Test
    public void testCreateIndex(){
        helloLucene.createIndex();
    }
}
</code></pre>
<p>运行完单元测试之后文件夹里多出来很多Lucene的文件，其中<code>segments_1</code>是段文件 Lucene首先会在段文件中找相应的索引信息    </p>
<p><img src="1.png" alt>  </p>
<h1 id="搜索初步"><a href="#搜索初步" class="headerlink" title="搜索初步"></a>搜索初步</h1><pre><code class="Java"> /**
     * 搜索
     */
    public  void searcher(){
        //1. 创建Directory
        Directory directory= null;
        try {
            directory = FSDirectory.open(new File(&quot;/Users/xxx/workspace/LuceneDemo/hellolucene/index&quot;));
        } catch (IOException e) {
            e.printStackTrace();
        }
        //2. 创建IndexReader
        IndexReader indexReader=null;
        try {
            indexReader=IndexReader.open(directory);
        } catch (IOException e) {
            e.printStackTrace();
        }
        //3. 根据IndexReader创建IndexSearch
        IndexSearcher indexSearcher=new IndexSearcher(indexReader);
        //创建parser来确定要搜索文件的内容,第二个参数表示搜索的域
        QueryParser queryParser=new QueryParser(Version.LUCENE_35,&quot;content&quot;,new StandardAnalyzer(Version.LUCENE_35));//第一个参数时版本,第二个参数时默认搜索域,第三个参数时分词器,其中分词器构造函数也需要版本
        //4. 创建搜索的Query 有很多Query，我们这里用最简单的QueryParser
        //根据QueryParser来创建Query 搜索域content中包含GIS的内容
        Query query=null;
        try {
            query=queryParser.parse(&quot;OpenLayers&quot;);//搜索的内容包含GIS的文档
        } catch (ParseException e) {
            e.printStackTrace();
        }
        //5. 根据Search搜索并且返回TopDocs
        TopDocs topDocs=null;
        try {
            topDocs=indexSearcher.search(query,10);//第二个表示搜索几条
        } catch (IOException e) {
            e.printStackTrace();
        }
        //6. 根据TopDocs获取ScoreDoc对象
        //TopDocs中存着ScoreDoc,是评分对象
        ScoreDoc[] scoreDoc=topDocs.scoreDocs;
        for(ScoreDoc sd:scoreDoc){
            //7. 根据Searcher和ScoreDoc对象获取具体的Document对象
            Document document=null;
            try {
                document=indexSearcher.doc(sd.doc);
            } catch (IOException e) {
                e.printStackTrace();
            }
            //8. 根据Document对象获取需要的值
            System.out.println(&quot;文件名&quot;+document.get(&quot;filename&quot;)+&quot;,文件路径&quot;+document.get(&quot;path&quot;));
        }


        //9. 关闭IndexReader
        try {
            indexReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<h1 id="索引创建-域选项"><a href="#索引创建-域选项" class="headerlink" title="索引创建  域选项"></a>索引创建  域选项</h1><p>索引建立步骤</p>
<p>1创建Directory</p>
<p>2创建Writer</p>
<p>3创建文档并且添加索引</p>
<p>4查询索引的基本信息</p>
<p>5删除和更新索引</p>
<h2 id="存储域选项"><a href="#存储域选项" class="headerlink" title="存储域选项"></a>存储域选项</h2><p>Field.Store.YES表示会把这个域中的内容完全存储到文件中，方便进行还原  </p>
<p>Field.Store.YES表示不存储内容到文件中,但是可以被索引 ,此时内容无法被还原(doc.get) </p>
<h2 id="索引域选项"><a href="#索引域选项" class="headerlink" title="索引域选项"></a>索引域选项</h2><p><img src="2.png" alt></p>
<p><code>Field.Index.ANALYZED</code> 进行分词和索引，适用于标题，内容等</p>
<p><code>Field.Index.NOT_ANALYZED</code> 进行索引，但是不进行分词，如果身份证号，姓名，ID等，适用于精确搜索</p>
<p><code>Field.Index.ANALYZED_NO_NORMS</code>  进行分词但不存储norms信息,这个norms包括了创建索引时间和权值等信息   排序有自己内部的评分规则 norms里面有些是因素</p>
<p><code>Field.Index.NOT_ANALYZED_NO_NORMS</code>  不分词也不存储norms信息</p>
<p><code>Field.Index.NO</code> 不进行索引</p>
<p><img src="3.png" alt> </p>
<p><img src="4.png" alt></p>
<p>fnm保存着域的信息  </p>
<p>fdx和fdt保存着Store为YES的属性信息   </p>
<p>frq 保存着哪些出现多少次,哪些相同的单词出现多少次  </p>
<p>nrm存储评分信息  </p>
<p>prx偏移量  </p>
<p>tii和tis存储索引里面所有信息</p>
<p>任一文件被删除索引就失效 </p>
<pre><code class="Java">public class IndexUtil {
    private String[] ids={&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;};
    private String[] emails={&quot;abc@qq.com&quot;,&quot;def@sina.com&quot;,&quot;ghi@gmail.com&quot;,&quot;rico@foxmail.com&quot;,&quot;jkl@163.com&quot;,&quot;mno@outlook.com&quot;};
    private String[] content={
            &quot;The apple is a deciduous tree, generally standing,China is its biggest market&quot;,
            &quot;China, officially the People&#39;s Republic of China (PRC), is a unitary sovereign state in East Asia&quot;,
            &quot;Donald John Trump (born June 14, 1946) is the 45th and current President of the United States, in office since January 20, 2017. Before entering politics, he was a businessman and television personality.He comes to China at 2017.10&quot;,
            &quot;Bees are flying insects closely related to wasps and ants,&quot;,
            &quot;Kotlin is a statically-typed programming language that runs on the Java virtual machine and also can be compiled to JavaScript source code or use the LLVM compiler infrastructure&quot;,
            &quot;he Yangtze , which is 6380 km long, is the longest river in Asia and the third-longest in the world&quot;
    };//邮件内容
    private int[] attachs={2,3,1,4,5,5};//附件数量
    private String[] names={&quot;rico&quot;,&quot;tom&quot;,&quot;linda&quot;,&quot;jake&quot;,&quot;rose&quot;,&quot;hanmeimei&quot;};

    private Directory directory=null;

    public IndexUtil(){
        try {
            //创建Directory
            directory= FSDirectory.open(new File(&quot;/Users/xxx/workspace/LuceneDemo/lucene_index/index&quot;));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void index() throws IOException {
        IndexWriter indexWriter=null;
        try {
            //创建IndexWriter
            indexWriter=new IndexWriter(directory,new IndexWriterConfig(Version.LUCENE_35,new StandardAnalyzer(Version.LUCENE_35)));
            Document doc=null;//Document相当于数据库表里的每一条记录 域相当于表中的每一个字段
            for(int i=0;i&lt;ids.length;i++){
                doc=new Document();//创建文档
                //域存储选项和域索引选项
                doc.add(new Field(&quot;id&quot;,ids[i],Field.Store.YES,Field.Index.NOT_ANALYZED_NO_NORMS));//Field相当于一个字段   Field.Store.YES表示是否把数据存储在索引里,将来可以把数据进行还原,id一般都要存储,邮件地址也要存储,内容不需要存储  id不需要分词也不需要加权
                doc.add(new Field(&quot;email&quot;,emails[i],Field.Store.YES,Field.Index.NOT_ANALYZED));//不分词，要加权
                doc.add(new Field(&quot;content&quot;,content[i],Field.Store.NO,Field.Index.ANALYZED));//要分词
                doc.add(new Field(&quot;names&quot;,names[i],Field.Store.YES,Field.Index.NOT_ANALYZED_NO_NORMS));
                indexWriter.addDocument(doc);
                  indexReader.close();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(indexWriter!=null){
                indexWriter.close();
            }
        }
    }

    public void query(){
        IndexReader indexReader=null;//使用IndexReader进行查询
        try {
            indexReader=IndexReader.open(directory);
            System.out.println(&quot;存储的doc数: &quot;+indexReader.numDocs());
            System.out.println(&quot;doc的总数: &quot;+indexReader.maxDoc());
              indexReader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }


    }
}
</code></pre>
<h1 id="索引的删除和更新"><a href="#索引的删除和更新" class="headerlink" title="索引的删除和更新"></a>索引的删除和更新</h1><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code class="Java">public void delete() throws IOException {
        IndexWriter indexWriter=null;

        try {
            indexWriter=new IndexWriter(directory,new IndexWriterConfig(Version.LUCENE_35,new StandardAnalyzer(Version.LUCENE_35)));
            //参数时一个选项，可以使一个query,query的结果可能是系列结果,可以把一系列全部删除  也可以是term  term是精确查找的值
            indexWriter.deleteDocuments(new Term(&quot;id&quot;,&quot;1&quot;));//删除id为1的
             indexWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(indexWriter!=null){
                indexWriter.close();
            }
        }
    }
</code></pre>
<pre><code class="Java"> @Test
    public void testDelete() throws IOException {
        IndexUtil indexUtil=new IndexUtil();
        indexUtil.delete();
    }
</code></pre>
<p>删除完之后再查询一下 </p>
<p><img src="5.png" alt> </p>
<p>Lucene像Windows一样，有回收站，删除的文档并不会完全删除,删完存储在回收站里面,删错了可以从回收站里恢复的,实际只有5个了，而且回收站里的搜索不了,删完之后索引文件多了一个<code>.del</code>   文件,删除的都在里面  </p>
<p><img src="6.png" alt> </p>
<p>query里面加一行<code>System.out.println(&quot;删除的文档数:&quot;+indexReader.numDeletedDocs());</code>可以输出删除的文档数目  </p>
<pre><code class="Java">public void recovery(){
        //使用IndexReader来恢复
        IndexReader reader= null;
        try {
            reader = IndexReader.open(directory);
            reader.undeleteAll();
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>运行报错了</p>
<p><img src="7.png" alt></p>
<p>是read only 如果是true，无法恢复 read本用于读的，所以默认readonly为true我们改为false  </p>
<pre><code class="Java">public void recovery(){
        //使用IndexReader来恢复
        IndexReader reader= null;
        try {
            reader = IndexReader.open(directory,false);//第二个参数是read only 如果是true，无法恢复 read本用于读的，所以默认readonly为true
            reader.undeleteAll();
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>我们执行一遍恢复再执行一遍查询 </p>
<p><img src="8.png" alt>  </p>
<p>而且目录下<code>.del</code>文件也删除了  </p>
<p>那么我们如何彻底删除 呢？ </p>
<p>3.5版本之前IndexWriter有个方法<code>optimize</code> (优化),但是已经被废弃了，因为一旦优化就要全部更新索引,负载很大,现在是<code>forceMerge</code></p>
<p>我们再执行一下删除方法,然后再执行一下下面的方法</p>
<pre><code class="Java">public void forceDelete() throws IOException {
        IndexWriter indexWriter=null;
        try {
            indexWriter=new IndexWriter(directory,new IndexWriterConfig(Version.LUCENE_35,new StandardAnalyzer(Version.LUCENE_35)));
            indexWriter.forceMergeDeletes();
            indexWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(indexWriter!=null){
                indexWriter.close();
            }
        }
    }
</code></pre>
<p><img src="9.png" alt>  </p>
<p>这样就彻底删除了  </p>
<p>当我们索引超出一定量的时候，Lucene会自动帮我们优化的,当然我们也可以手动强制更新   </p>
<p><code>indexWriter.deleteAll();</code>可以立即彻底删除所有索引 </p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新前</p>
<pre><code>存储的doc数: 6
doc的总数: 6
删除的文档数:0
</code></pre><p>更新的代码</p>
<pre><code class="Java">public void update() throws IOException {
        IndexWriter indexWriter=null;
        try {
            indexWriter=new IndexWriter(directory,new IndexWriterConfig(Version.LUCENE_35,new StandardAnalyzer(Version.LUCENE_35)));
            /*Lucene并没有提供更新方法,这里的更新操作其实是2个操作的集合
            *先删除之后再添加
            */
            Document doc=new Document();
            doc.add(new Field(&quot;id&quot;,&quot;11&quot;,Field.Store.YES,Field.Index.NOT_ANALYZED_NO_NORMS));//Field相当于一个字段   Field.Store.YES表示是否把数据存储在索引里,将来可以把数据进行还原,id一般都要存储,邮件地址也要存储,内容不需要存储  id不需要分词也不需要加权
            doc.add(new Field(&quot;email&quot;,emails[0],Field.Store.YES,Field.Index.NOT_ANALYZED));//不分词，要加权
            doc.add(new Field(&quot;content&quot;,content[0],Field.Store.NO,Field.Index.ANALYZED));//要分词
            doc.add(new Field(&quot;names&quot;,names[0],Field.Store.YES,Field.Index.NOT_ANALYZED_NO_NORMS));
            indexWriter.updateDocument(new Term(&quot;id&quot;,&quot;1&quot;),doc);//第一个参数：匹配的Term 第二个新传入Document
            //其实是先把id为1的进行删除,
            indexWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(indexWriter!=null){
                indexWriter.close();
            }
        }
    }
</code></pre>
<p>更新后</p>
<pre><code>存储的doc数: 6
doc的总数: 7
删除的文档数:1
</code></pre><p>说明了更新的确是先删除再增加  </p>
<p>总结：删除</p>
<p><img src="10.png" alt> 存到回收站中</p>
<p>恢复删除  <code>IndexReader.undeleteAll</code>  </p>
<p>强制删除 3.5之前<code>optimize</code> 之后 <code>forceMergeDelete</code>  </p>
<p>优化合并 (不建议使用) </p>
<p><code>writer.forceMerge(2)</code> </p>
<p>更新索引(先删除后添加)</p>
<p><img src="11.png" alt> </p>
<h2 id="索引加权操作"><a href="#索引加权操作" class="headerlink" title="索引加权操作"></a>索引加权操作</h2><p>在建索引的时候可以为文档加权 </p>
<p><code>doc.setBoost();//默认是1.0 值越高说明加权值也就越高，得分越高,排序越靠前</code> </p>
<p>搜索的代码</p>
<pre><code class="Java">public void search(){
        IndexReader indexReader=null;
        try {
            indexReader=IndexReader.open(directory);
            IndexSearcher searcher=new IndexSearcher(indexReader);
            TermQuery termQuery=new TermQuery(new Term(&quot;content&quot;,&quot;china&quot;));//搜索content字段中包含China的
            TopDocs tds=searcher.search(termQuery,10);//搜索前10条
            for(ScoreDoc sd:tds.scoreDocs){
               Document doc=searcher.doc(sd.doc);
               System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>重新删除索引，重建索引，然后运行搜索的测试用例</p>
<p>结果 </p>
<p><img src="12.png" alt></p>
<p>tom的排名第一，然后是rico的，然后是linda </p>
<p>为什么这么排序呢？ </p>
<p>我们看一下数据发现  tom的content里面出现了多次china</p>
<p><img src="13.png" alt> </p>
<p>所以他排名高一点，那么后面2位的排名为什么这么排我们就不得而知了    </p>
<p>接着我们加入评分  </p>
<p><img src="14.png" alt>  </p>
<p>再运行搜索，结果  </p>
<p><img src="15.png" alt> </p>
<p>这是因为qq.com的权重高,gmail的次之</p>
<h1 id="使用Luke工具查看索引"><a href="#使用Luke工具查看索引" class="headerlink" title="使用Luke工具查看索引"></a>使用Luke工具查看索引</h1><p><img src="16.png" alt></p>
<p><img src="17.png" alt> </p>
<p>norm是加权信息  分数 这里我们存储了email  id  names  没有存储content</p>
<p>创建索引时我们没有对email分词，所以这里显示的也的确是没有分词 </p>
<p><img src="18.png" alt> </p>
<h1 id="对时间和日期进行索引"><a href="#对时间和日期进行索引" class="headerlink" title="对时间和日期进行索引"></a>对时间和日期进行索引</h1><p><img src="19.png" alt> </p>
<p>name是String,value还是String，所以不能用Field,要用NumberField  </p>
<pre><code class="Java">doc.add(new NumericField(&quot;attach&quot;,Field.Store.YES,true).setIntValue(attachs[i]));//存储附件  存储,索引,不分词, 默认就不分词也没有权值，所以没有这个选项
doc.add(new NumericField(&quot;date&quot;,Field.Store.YES,true).setLongValue(dates[i].getTime()));//存储日期 存储+索引(方便根据日期查找)
</code></pre>
<p>拿到结果  </p>
<pre><code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
Date date= new Date(dateLong);
String dateStr=sdf.format(date);//long型日期转成日期型  
System.out.println(&quot;文档日期:&quot;+dateStr);
</code></pre><p><img src="20.png" alt> </p>
<p>搜索到的doc获取其权值全为1，因为这不是设置的时候的doc,因为搜索结果是一个新的doc对象，把搜索结果赋过来,加权信息没有的，看权值要用luke查看</p>
<p><img src="21.png" alt> </p>
<p>scores一般和2个相关，一个是设置的权值，一个是文档出现的次数。 具体的评分规则很复杂 </p>
<p><img src="22.png" alt> </p>
<h1 id="IndexReader的设计"><a href="#IndexReader的设计" class="headerlink" title="IndexReader的设计"></a>IndexReader的设计</h1><p><code>IndexReader</code>和<code>IndexWriter</code>打开和关闭都是非常耗时的操作,特别是<code>IndexReader</code>   </p>
<p>所以IndexReader最好设计成单例的   </p>
<p>但是单例会存在一个问题: </p>
<p>就是在reader过程中，且reader没有关闭，indexwriter进行了数据的增删，reader搜索到的内容不受影响  </p>
<p><code>IndexReader.openIfChanged</code>能解决这个问题  </p>
<p>所以我们重写getSearcher方法</p>
<pre><code class="Java">public  IndexSearcher getSearcher(){
        try {
            if(indexReader==null){
                indexReader=IndexReader.open(directory);
            }else{
                IndexReader newReader=IndexReader.openIfChanged(indexReader);//如果索引改变了,返回新的IndexReader,没改变则返回null
                if(newReader!=null){
                    indexReader.close();//旧的关闭
                    indexReader=newReader;
                }

            }
            return  new IndexSearcher(indexReader);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
</code></pre>
<p>这样,id为1的删除了，而且reader也能获取新的值 </p>
<p><img src="23.png" alt></p>
<p>当IndexWriter也是单例的时候，在原来close的地方调用<code>writter.commit();</code>进行提交</p>
<h1 id="使用reader进行删除"><a href="#使用reader进行删除" class="headerlink" title="使用reader进行删除"></a>使用reader进行删除</h1><pre><code class="java">    //reader也能删
    public void delete2(){
        IndexReader reader= null;
        try{
            reader = IndexReader.open(directory,false);//外面静态全局的reader是只读的，我们这里new一个可写的
            reader.deleteDocuments(new Term(&quot;id&quot;,&quot;1&quot;));//reader也可以删除文档
            reader.close();//一定要close才会提交(删除) 
        } catch (StaleReaderException e) {
            e.printStackTrace();
        } catch (LockObtainFailedException e) {
            e.printStackTrace();
        } catch (CorruptIndexException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p> 使用reader方式进行删除实际上是根据reader来new了一个writer进行删除操作的(原来的Lucene还有个<code>writer.getreader()</code>方法的，后来弃用了),这种删除方式直接就更新了reader里的索引信息了(不然还要<code>IndexReader.openIfChanged(indexReader)</code>)  </p>
<p>还可以按照存储时的序号来删,一般不这么做<code>reader.deleteDocument(int i);</code> </p>
<h1 id="Directory的几种操作方式"><a href="#Directory的几种操作方式" class="headerlink" title="Directory的几种操作方式"></a>Directory的几种操作方式</h1><p><img src="24.png" alt></p>
<p>Lucene3.5的api </p>
<p>Lucene7.1的api  </p>
<p> <a href="http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/Directory.html" target="_blank" rel="noopener">http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/Directory.html</a></p>
<p><img src="25.png" alt></p>
<p><img src="26.png" alt></p>
<p><img src="27.png" alt></p>
<p><img src="28.png" alt></p>
<p>Base class for Directory implementations that store index files in the file system. </p>
<p>There are currently three core subclasses:</p>
<ul>
<li><a href="http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/SimpleFSDirectory.html" target="_blank" rel="noopener"><code>SimpleFSDirectory</code></a> is a straightforward implementation using Files.newByteChannel. However, it has poor concurrent performance (multiple threads will bottleneck) as it synchronizes when multiple threads read from the same file.</li>
<li><a href="http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/NIOFSDirectory.html" target="_blank" rel="noopener"><code>NIOFSDirectory</code></a> uses java.nio’s FileChannel’s positional io when reading to avoid synchronization when reading from the same file. Unfortunately, due to a Windows-only <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734" target="_blank" rel="noopener">Sun JRE bug</a> this is a poor choice for Windows, but on all other platforms this is the preferred choice. Applications using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html?is-external=true#interrupt--" target="_blank" rel="noopener"><code>Thread.interrupt()</code></a> or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html?is-external=true#cancel-boolean-" target="_blank" rel="noopener"><code>Future.cancel(boolean)</code></a> should use <code>RAFDirectory</code> instead. See <a href="http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/NIOFSDirectory.html" target="_blank" rel="noopener"><code>NIOFSDirectory</code></a> java doc for details.</li>
<li><a href="http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/MMapDirectory.html" target="_blank" rel="noopener"><code>MMapDirectory</code></a> uses memory-mapped IO when reading. This is a good choice if you have plenty of virtual memory relative to your index size, eg if you are running on a 64 bit JRE, or you are running on a 32 bit JRE but your index sizes are small enough to fit into the virtual memory space. Java has currently the limitation of not being able to unmap files from user code. The files are unmapped, when GC releases the byte buffers. Due to <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4724038" target="_blank" rel="noopener">this bug</a> in Sun’s JRE, MMapDirectory’s <a href="http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/IndexInput.html#close--" target="_blank" rel="noopener"><code>IndexInput.close()</code></a> is unable to close the underlying OS file handle. Only when GC finally collects the underlying objects, which could be quite some time later, will the file handle be closed. This will consume additional transient disk usage: on Windows, attempts to delete or overwrite the files will result in an exception; on other platforms, which typically have a “delete on last close” semantics, while such operations will succeed, the bytes are still consuming space on disk. For many applications this limitation is not a problem (e.g. if you have plenty of disk space, and you don’t rely on overwriting files on Windows) but it’s still an important limitation to be aware of. This class supplies a (possibly dangerous) workaround mentioned in the bug report, which may fail on non-Sun JVMs.</li>
</ul>
<p>Unfortunately, because of system peculiarities, there is no single overall best implementation. Therefore, we’ve added the <a href="http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/FSDirectory.html#open-java.nio.file.Path-" target="_blank" rel="noopener"><code>open(java.nio.file.Path)</code></a> method, to allow Lucene to choose the best FSDirectory implementation given your environment, and the known limitations of each implementation. For users who have no reason to prefer a specific implementation, it’s best to simply use <a href="http://lucene.apache.org/core/7_1_0/core/org/apache/lucene/store/FSDirectory.html#open-java.nio.file.Path-" target="_blank" rel="noopener"><code>open(java.nio.file.Path)</code></a>. For all others, you should instantiate the desired implementation directly.</p>
<p><strong>NOTE:</strong> Accessing one of the above subclasses either directly or indirectly from a thread while it’s interrupted can close the underlying channel immediately if at the same time the thread is blocked on IO. The channel will remain closed and subsequent access to the index will throw a <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ClosedChannelException.html?is-external=true" target="_blank" rel="noopener"><code>ClosedChannelException</code></a>. Applications using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html?is-external=true#interrupt--" target="_blank" rel="noopener"><code>Thread.interrupt()</code></a> or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html?is-external=true#cancel-boolean-" target="_blank" rel="noopener"><code>Future.cancel(boolean)</code></a> should use the slower legacy <code>RAFDirectory</code> from the <code>misc</code> Lucene module instead.</p>
<p>SimpleFSDirectory开销是最小的，但是多线程支持不好  </p>
<p>NIO对于Windows支持不太好  </p>
<p>MMapDirectory对于64位的会快一点   </p>
<p>我们只要使用<code>FSDirectory.open</code>就可以了，Lucene会根据当前的运行环境自动选择最合适的Directory  </p>
<p>RAMDirectory 把索引存到内存中，好处：快  坏处：不能持久化  </p>
<p>也可以把已经持久化的存到内存里(<code>RAMDirectory(Directory dir)</code>) </p>
<h1 id="TermRange等基本操作"><a href="#TermRange等基本操作" class="headerlink" title="TermRange等基本操作"></a>TermRange等基本操作</h1><h2 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h2><pre><code class="Java">    //精确匹配查询
    public void searchByTerm(String field,String value,int num) throws IOException {
        IndexSearcher indexSearcher=getSearcher();
        Query query=new TermQuery(new Term(field,value));
        TopDocs tds=indexSearcher.search(query,num);
        System.out.println(&quot;一共查询到&quot;+tds.totalHits+&quot;条记录&quot;);
        for(ScoreDoc sd:tds.scoreDocs){
            Document doc=indexSearcher.doc(sd.doc);
            //---输出----
            System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; 权值:&quot;+doc.getBoost()+&quot; 评分:&quot;+sd.score+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
            Date date= new Date(dateLong);
            String dateStr=sdf.format(date);
            System.out.println(&quot;文档附件数量:&quot;+doc.get(&quot;attach&quot;)+&quot; 文档日期:&quot;+dateStr);
        }
        indexSearcher.close();
    }
</code></pre>
<pre><code class="Java">    @Test
    public void testSearch() throws IOException {
        searcherUtil.searchByTerm(&quot;content&quot;,&quot;i&quot;,3);
    }
</code></pre>
<p><img src="29.png" alt>  </p>
<p>我们只要求取3条，但是总共仍然有6条。说明总共查询出来的值(totalHits是总记录数)和我们传入的num一点关系都没有   </p>
<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><pre><code class="Java">//范围查询
public void searchByTermRange(String field,String start,String end,int num) throws IOException {
    IndexSearcher indexSearcher=getSearcher();
    Query query=new TermRangeQuery(field,start,end,true,true);//field start end 是否包含最底下的(includeLower) 是否包含最上面的(includeUpper)  可以理解为开区间闭区间
    TopDocs tds=indexSearcher.search(query,num);
    System.out.println(&quot;一共查询到&quot;+tds.totalHits+&quot;条记录&quot;);
    for(ScoreDoc sd:tds.scoreDocs){
        Document doc=indexSearcher.doc(sd.doc);
        //---输出----
        System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; 权值:&quot;+doc.getBoost()+&quot; 评分:&quot;+sd.score+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
        Date date= new Date(dateLong);
        String dateStr=sdf.format(date);
        System.out.println(&quot;文档附件数量:&quot;+doc.get(&quot;attach&quot;)+&quot; 文档日期:&quot;+dateStr);
    }
    indexSearcher.close();
}
</code></pre>
<pre><code class="Java">    @Test
    public void testSearchByTermRange() throws IOException {
        searcherUtil.searchByTermRange(&quot;id&quot;,&quot;1&quot;,&quot;3&quot;,10);
    }
</code></pre>
<p><img src="30.png" alt> </p>
<p>当<code>Query query=new TermRangeQuery(field,start,end,true,false)</code> 结果是1,2 </p>
<p>当<code>Query query=new TermRangeQuery(field,start,end,false,true)</code> 结果是2,3</p>
<p>当<code>Query query=new TermRangeQuery(field,start,end,false,false)</code> 结果是2</p>
<p><code>searcherUtil.searchByTermRange(&quot;names&quot;,&quot;a&quot;,&quot;s&quot;,10);</code> 查询名字包含从a到s字母的  </p>
<p><img src="31.png" alt></p>
<p>tom没有，因为t在s后面 </p>
<h2 id="数字范围查询"><a href="#数字范围查询" class="headerlink" title="数字范围查询"></a>数字范围查询</h2><pre><code class="Java">    public void searchByNumricRange(String field,int start ,int end,int num) throws IOException {
        IndexSearcher indexSearcher=getSearcher();
        Query query=NumericRangeQuery.newIntRange(field,start,end,true,true);//最后2个仍然是是否开闭区间(是否包含)
        TopDocs tds=indexSearcher.search(query,num);
        System.out.println(&quot;一共查询到&quot;+tds.totalHits+&quot;条记录&quot;);
        for(ScoreDoc sd:tds.scoreDocs){
            Document doc=indexSearcher.doc(sd.doc);
            //---输出----
            System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; 权值:&quot;+doc.getBoost()+&quot; 评分:&quot;+sd.score+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
            Date date= new Date(dateLong);
            String dateStr=sdf.format(date);
            System.out.println(&quot;文档附件数量:&quot;+doc.get(&quot;attach&quot;)+&quot; 文档日期:&quot;+dateStr);
        }
        indexSearcher.close();
    }
</code></pre>
<p><img src="32.png" alt> </p>
<p>找到的文档的附件数量是从1到3的  </p>
<p>目前还没有按照附件数量进行排序，而是按照文档序号进行排序的  </p>
<h1 id="其他常用Query查询"><a href="#其他常用Query查询" class="headerlink" title="其他常用Query查询"></a>其他常用Query查询</h1><h2 id="前缀匹配搜索"><a href="#前缀匹配搜索" class="headerlink" title="前缀匹配搜索"></a>前缀匹配搜索</h2><pre><code class="Java">    //前缀搜索 匹配前缀
    public void searchByPrefix(String field,String value,int nums) throws IOException {
        IndexSearcher indexSearcher=getSearcher();
        Query query=new PrefixQuery(new Term(field,value));//支持前缀搜索
        TopDocs tds=indexSearcher.search(query,nums);
        System.out.println(&quot;一共查询到&quot;+tds.totalHits+&quot;条记录&quot;);
        for(ScoreDoc sd:tds.scoreDocs){
            Document doc=indexSearcher.doc(sd.doc);
            //---输出----
            System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; 权值:&quot;+doc.getBoost()+&quot; 评分:&quot;+sd.score+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
            Date date= new Date(dateLong);
            String dateStr=sdf.format(date);
            System.out.println(&quot;文档附件数量:&quot;+doc.get(&quot;attach&quot;)+&quot; 文档日期:&quot;+dateStr);
        }
        indexSearcher.close();
    }
</code></pre>
<pre><code class="Java">    @Test
    public void testSearchByPrefix() throws IOException {
        searcherUtil.searchByPrefix(&quot;names&quot;,&quot;r&quot;,9);//搜索r开头的名字
    }
</code></pre>
<p><img src="33.png" alt> </p>
<p>结果依然没排序,因为权值在content里面  </p>
<p>也可以搜索content以”xx”开头的  </p>
<h2 id="通配符搜索"><a href="#通配符搜索" class="headerlink" title="通配符搜索"></a>通配符搜索</h2><pre><code class="Java">    //通配符搜索
    public void searchByWildCard(String field,String value,int nums) throws IOException {
        IndexSearcher indexSearcher=getSearcher();
        Query query=new WildcardQuery(new Term(field,value));//支持前缀搜索
        TopDocs tds=indexSearcher.search(query,nums);
        System.out.println(&quot;一共查询到&quot;+tds.totalHits+&quot;条记录&quot;);
        for(ScoreDoc sd:tds.scoreDocs){
            Document doc=indexSearcher.doc(sd.doc);
            //---输出----
            System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; 权值:&quot;+doc.getBoost()+&quot; 评分:&quot;+sd.score+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
            Date date= new Date(dateLong);
            String dateStr=sdf.format(date);
            System.out.println(&quot;文档附件数量:&quot;+doc.get(&quot;attach&quot;)+&quot; 文档日期:&quot;+dateStr);
        }
        indexSearcher.close();
    }
</code></pre>
<pre><code class="Java">    @Test
    public void testSearchByWildCard() throws IOException {
        searcherUtil.searchByWildCard(&quot;names&quot;,&quot;r*&quot;,9);//*表示任意多个字符 ?表示一个字符
    }
</code></pre>
<h2 id="booleanQuery-连接多个子查询"><a href="#booleanQuery-连接多个子查询" class="headerlink" title="booleanQuery 连接多个子查询"></a>booleanQuery 连接多个子查询</h2><pre><code class="Java">    //连接多个子查询
    public void searchByBoolean(int nums) throws IOException {
        IndexSearcher indexSearcher=getSearcher();
        BooleanQuery query=new BooleanQuery();
        //query.add(new TermQuery(new Term(&quot;names&quot;,&quot;rico&quot;)), BooleanClause.Occur.MUST);//Occur.MUST意思是名字必须是rico
        query.add(new TermQuery(new Term(&quot;names&quot;,&quot;rico&quot;)), BooleanClause.Occur.SHOULD);//Occur.Should意思表示可以出现也可以不出现  
        query.add(new TermQuery(new Term(&quot;content&quot;,&quot;china&quot;)), BooleanClause.Occur.MUST);//要查询名字中有rico，且content中必须有china的
        TopDocs tds=indexSearcher.search(query,nums);
        System.out.println(&quot;一共查询到&quot;+tds.totalHits+&quot;条记录&quot;);
        for(ScoreDoc sd:tds.scoreDocs){
            Document doc=indexSearcher.doc(sd.doc);
            //---输出----
            System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; 权值:&quot;+doc.getBoost()+&quot; 评分:&quot;+sd.score+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
            Date date= new Date(dateLong);
            String dateStr=sdf.format(date);
            System.out.println(&quot;文档附件数量:&quot;+doc.get(&quot;attach&quot;)+&quot; 文档日期:&quot;+dateStr);
        }
        indexSearcher.close();
    }
</code></pre>
<pre><code class="Java">    @Test
    public void testBooleanQuery() throws IOException {
        searcherUtil.searchByBoolean(9);
    }
</code></pre>
<p><code>BooleanClause.Occur.MUST</code> 表示必须出现   </p>
<p><code>BooleanClause.Occur.SHOULD</code>表示可以出现也可以不出现   </p>
<p><code>BooleanClause.Occur.MUST_NOT</code>表示必须没有 </p>
<h2 id="PhraseQuery-短语查询"><a href="#PhraseQuery-短语查询" class="headerlink" title="PhraseQuery 短语查询"></a>PhraseQuery 短语查询</h2><p>对于中文搜索没什么用，对于英文搜索来说很有用   分词主要按照空格来分词  </p>
<p>以<code>i like football</code> 举例 </p>
<p><code>i football</code> 中间有1跳(slop) </p>
<pre><code class="Java">    //短语搜索
    public void searchByPhrase(int nums) throws IOException {
        IndexSearcher indexSearcher=getSearcher();
        PhraseQuery query=new PhraseQuery();
        query.setSlop(1);//slop表示有几跳
        //第一个Term
        query.add(new Term(&quot;content&quot;,&quot;i&quot;));
        //产生距离后的第二个term
        query.add(new Term(&quot;content&quot;,&quot;apple&quot;));
        TopDocs tds=indexSearcher.search(query,nums);
        System.out.println(&quot;一共查询到&quot;+tds.totalHits+&quot;条记录&quot;);
        for(ScoreDoc sd:tds.scoreDocs){
            Document doc=indexSearcher.doc(sd.doc);
            //---输出----
            System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; 权值:&quot;+doc.getBoost()+&quot; 评分:&quot;+sd.score+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
            Date date= new Date(dateLong);
            String dateStr=sdf.format(date);
            System.out.println(&quot;文档附件数量:&quot;+doc.get(&quot;attach&quot;)+&quot; 文档日期:&quot;+dateStr);
        }
        indexSearcher.close();
    }
</code></pre>
<p>搜索i中间一个字，然后apple 例如 i like apple   </p>
<p>文中的顺序也是按照add的顺序？待考证</p>
<h2 id="fuzzyQuery-模糊查询"><a href="#fuzzyQuery-模糊查询" class="headerlink" title="fuzzyQuery 模糊查询"></a>fuzzyQuery 模糊查询</h2><pre><code class="Java">    //模糊查询
    public void searchByFuzzy(int nums) throws IOException {
        IndexSearcher indexSearcher=getSearcher();
        //FuzzyQuery query=new FuzzyQuery(new Term(&quot;names&quot;,&quot;ri&quot;),0.1f,0);
        FuzzyQuery query=new FuzzyQuery(new Term(&quot;names&quot;,&quot;tam&quot;));
        System.out.println(query.getMinSimilarity());//获取最小相似度 这些参数少用，会影响效率的 意义也不大
        System.out.println(query.getPrefixLength());//距离
        TopDocs tds=indexSearcher.search(query,nums);
        System.out.println(&quot;一共查询到&quot;+tds.totalHits+&quot;条记录&quot;);
        for(ScoreDoc sd:tds.scoreDocs){
            Document doc=indexSearcher.doc(sd.doc);
            //---输出----
            System.out.println(&quot;文档序号: &quot;+sd.doc+&quot; 权值:&quot;+doc.getBoost()+&quot; 评分:&quot;+sd.score+&quot; id:&quot;+doc.get(&quot;id&quot;)+&quot; name: &quot;+doc.get(&quot;names&quot;)+&quot; email:&quot;+doc.get(&quot;email&quot;));
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            Long dateLong=Long.valueOf(doc.get(&quot;date&quot;));
            Date date= new Date(dateLong);
            String dateStr=sdf.format(date);
            System.out.println(&quot;文档附件数量:&quot;+doc.get(&quot;attach&quot;)+&quot; 文档日期:&quot;+dateStr);
        }
        indexSearcher.close();
    }
</code></pre>
<p><img src="34.png" alt> </p>
<p>查 <code>tam</code> 把tom查出来   ,因为是模糊查询，默认是1个距离 </p>
<p>这个模糊查询对中文搜索没有什么帮助 </p>
<h1 id="QueryParse"><a href="#QueryParse" class="headerlink" title="QueryParse"></a>QueryParse</h1><pre><code class="Java">//通过Parse生成Query 搜索content中包含china的
Query query=queryParser.parse(&quot;china&quot;);
</code></pre>
<p><img src="37.png" alt> </p>
<p><code>query=queryParser.parse(&quot;names:r*&quot;);//改变搜索域为names  并搜索names为r开头的</code> </p>
<p><img src="35.png" alt> </p>
<p><code>query=queryParser.parse(&quot;names:tom&quot;);//改变搜索域为names  并搜索names为rico的</code> </p>
<p><img src="36.png" alt> </p>
<p><code>Query query=queryParser.parse(&quot;longest river&quot;);</code>搜索内容中带有longest 或 river的 (只有longest ，只有river,两者都有)  </p>
<p><img src="38.png" alt> </p>
<p>同时匹配 使用关键词 AND</p>
<p><code>Query query=queryParser.parse(&quot;longest AND river&quot;);</code>   </p>
<p><img src="42.png" alt> </p>
<p>也可以将空格代表or改为代表and</p>
<pre><code class="Java">    //改变空格的默认操作符(本来是or),以下可以改成AND,这样空格也是AND了
    queryParser.setDefaultOperator(QueryParser.Operator.AND);
    Query query=queryParser.parse(&quot;longest river&quot;);
</code></pre>
<p>这样搜索content既有longest也有river的   </p>
<p><img src="39.png" alt> </p>
<p>查询<code>@qq.com</code>结尾的email </p>
<p><code>Query query=queryParser.parse(&quot;email: *@qq.com&quot;);</code> </p>
<p>但是报错了  </p>
<p><img src="40.png" alt> </p>
<p>因为如果匹配任意开头，特定结尾的效率非常低，Lucene默认是关闭的，我们来打开它  </p>
<pre><code class="Java">queryParser.setAllowLeadingWildcard(true);//开启第一个字符的通配符匹配(默认关闭，因为效率比较低)
Query query=queryParser.parse(&quot;email: *@qq.com&quot;);
</code></pre>
<p><img src="41.png" alt> </p>
<p><code>Query query=queryParser.parse(&quot;- names:linda  + china &quot;);</code> 匹配内容中有china 但是names不是linda的 </p>
<p><code>-names: linda</code>表示name field不是linda  china不需要加fieldName是因为content是默认搜索域   </p>
<p>注意加减号前后要加空格 ,且加减放在条件前面  </p>
<p><img src="43.png" alt> </p>
<p>这里把linda过滤掉了(linda的内容也有china)    </p>
<p>匹配一个区间</p>
<p><code>Query query=queryParser.parse(&quot;id:[1 TO 3]&quot;);</code>   匹配id从1到3 </p>
<p><img src="44.png" alt> </p>
<p>TO必须是大写，不能是小写，否则会报错  </p>
<p>开区间是中括号，闭区间是花括号   </p>
<p><code>Query query=queryParser.parse(&quot;id:{1 TO 3}&quot;);</code> </p>
<p><img src="45.png" alt> </p>
<p>短语匹配 </p>
<p>我们先来看 </p>
<p><code>Query query=queryParser.parse(&quot;i like&quot;);</code> 根据上面的只是，我们知道会匹配只有i  只有like 既有i也有like的 </p>
<p><img src="46.png" alt> </p>
<p>但是我想完全匹配i like连起来的情况  </p>
<p>可以这样写</p>
<pre><code class="Java">Query query=queryParser.parse(&quot;\&quot;i like\&quot;&quot;);// 反斜杠包起来表示一个短语
</code></pre>
<p><img src="47.png" alt> </p>
<p><img src="48.png" alt> </p>
<p>对于queryParse还是content,在i和like中加多少个空格都当成是一个空格  </p>
<p><code>i  like=i like=i     like</code>  </p>
<p><code>Query query=queryParser.parse(&quot;\&quot;i  china\&quot;~1&quot;);</code>表示i和china中可以有一个单词  最后匹配了i like china  </p>
<p><img src="49.png" alt> </p>
<p>模糊查询 </p>
<p>我们把名字一个改成和rico差一个单词的rica  </p>
<p><code>Query query=queryParser.parse(&quot;names:rico~&quot;);</code>  模糊查询 可以有1个字母的不一样</p>
<p><img src="50.png" alt></p>
<p>没有办法匹配数字 ，上面的<code>Query query=queryParser.parse(&quot;id:{1 TO 3}&quot;);</code> 的id是string型的 </p>
<p>如要匹配数字，需要自己扩展parse(下节内容)  </p>
<h1 id="分页搜索"><a href="#分页搜索" class="headerlink" title="分页搜索"></a>分页搜索</h1><p>两种方式 再查询和3.5版本之后提供的searchAfter  </p>
<h2 id="再查询的方式"><a href="#再查询的方式" class="headerlink" title="再查询的方式"></a>再查询的方式</h2><p>视频中的例子： </p>
<p>首先将各个txt文件重新拷贝一份，并修改后缀名，多拷几分好做分页  </p>
<p><img src="51.png" alt> </p>
<p><img src="52.png" alt> </p>
<p>然后将这些文件全部加索引  </p>
<pre><code class="Java">public class FileIndexUtils {
    private static Directory directory = null;
    static{
        try {
            directory = FSDirectory.open(new File(&quot;d:/lucene/files/&quot;));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static Directory getDirectory() {
        return directory;
    }

    public static void index(boolean hasNew) {
        IndexWriter writer = null;
        try {
            writer = new IndexWriter(directory, new IndexWriterConfig(Version.LUCENE_35, new StandardAnalyzer(Version.LUCENE_35)));
            if(hasNew) {
                writer.deleteAll();
            }
            File file = new File(&quot;d:/lucene/example&quot;);
            Document doc = null;
            for(File f:file.listFiles()) {
                doc = new Document();
                doc.add(new Field(&quot;content&quot;,new FileReader(f)));//不存储 
                doc.add(new Field(&quot;filename&quot;,f.getName(),Field.Store.YES,Field.Index.NOT_ANALYZED));//存储 分词 
                doc.add(new Field(&quot;path&quot;,f.getAbsolutePath(),Field.Store.YES,Field.Index.NOT_ANALYZED));//存储 不分词 
                doc.add(new NumericField(&quot;date&quot;,Field.Store.YES,true).setLongValue(f.lastModified()));//日期  修改日期 存储，(不存在分词的概念)
                doc.add(new NumericField(&quot;size&quot;,Field.Store.YES,true).setIntValue((int)(f.length()/1024)));//存储 转换成k 
                writer.addDocument(doc);
            }
        } catch (CorruptIndexException e) {
            e.printStackTrace();
        } catch (LockObtainFailedException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if(writer!=null) writer.close();
            } catch (CorruptIndexException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>example是文件存放的地方  files是存放索引的地方  </p>
<pre><code class="Java">    @Test
    public void indexFile() {
        FileIndexUtils.index(true);
    }
</code></pre>
<p>分页查询</p>
<pre><code class="Java">    public void searchPage(String query,int pageIndex,int pageSize) {
        try {
            Directory dir = FileIndexUtils.getDirectory();
            IndexSearcher searcher = getSearcher(dir);
            QueryParser parser = new QueryParser(Version.LUCENE_35,&quot;content&quot;,new StandardAnalyzer(Version.LUCENE_35));
            Query q = parser.parse(query);
            TopDocs tds = searcher.search(q, 500);
            ScoreDoc[] sds = tds.scoreDocs;
            int start = (pageIndex-1)*pageSize;
            int end = pageIndex*pageSize;
            for(int i=start;i&lt;end;i++) {
                Document doc = searcher.doc(sds[i].doc);
                System.out.println(sds[i].doc+&quot;:&quot;+doc.get(&quot;path&quot;)+&quot;--&gt;&quot;+doc.get(&quot;filename&quot;));
            }

            searcher.close();
        } catch (org.apache.lucene.queryParser.ParseException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>这种方式就是把所有数据查出来再来做处理  </p>
<pre><code class="Java">    @Test
    public void testSearchPage01() {
        su.searchPage(&quot;java&quot;, 2,20);//第二页 每页20条数据  
        System.out.println(&quot;-------------------------------&quot;);
//        su.searchNoPage(&quot;java&quot;);
        su.searchPageByAfter(&quot;java&quot;, 2,20);
    }
</code></pre>
<h2 id="SearchAfter的方式"><a href="#SearchAfter的方式" class="headerlink" title="SearchAfter的方式"></a>SearchAfter的方式</h2><p>3.5版本之后才出现 </p>
<p><img src="54.png" alt> </p>
<p>改造如下 </p>
<pre><code class="Java">    /**
     * 根据页码和分页大小获取上一次的最后一个ScoreDoc
     */
    private ScoreDoc getLastScoreDoc(int pageIndex,int pageSize,Query query,IndexSearcher searcher) throws IOException {
        if(pageIndex==1)return null;//如果是第一页就返回空
        int num = pageSize*(pageIndex-1);//获取上一页的数量  第一页20 第二页就是40了 这样刚好能够包含上一页最后一个  假如最后翻到100页，那么最后是2000条,这样比每次num都是2000条效率高  
        TopDocs tds = searcher.search(query, num);
        return tds.scoreDocs[num-1];
    }
</code></pre>
<pre><code class="Java">    public void searchPageByAfter(String query,int pageIndex,int pageSize) {
        try {
            Directory dir = FileIndexUtils.getDirectory();
            IndexSearcher searcher = getSearcher(dir);
            QueryParser parser = new QueryParser(Version.LUCENE_35,&quot;content&quot;,new StandardAnalyzer(Version.LUCENE_35));
            Query q = parser.parse(query);
            //先获取上一页的最后一个元素
            ScoreDoc lastSd = getLastScoreDoc(pageIndex, pageSize, q, searcher);
            //通过最后一个元素搜索下页的pageSize个元素
            TopDocs tds = searcher.searchAfter(lastSd,q, pageSize);
            for(ScoreDoc sd:tds.scoreDocs) {
                Document doc = searcher.doc(sd.doc);
                System.out.println(sd.doc+&quot;:&quot;+doc.get(&quot;path&quot;)+&quot;--&gt;&quot;+doc.get(&quot;filename&quot;));
            }
            searcher.close();
        } catch (org.apache.lucene.queryParser.ParseException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p><img src="53.png" alt>  </p>
<pre><code class="Java">    @Test
    public void testSearchPage02() {
        su.searchPageByAfter(&quot;java&quot;, 3,20);
    }
</code></pre>
<h1 id="分词器的原理"><a href="#分词器的原理" class="headerlink" title="分词器的原理"></a>分词器的原理</h1><p>所有的分词器都要继承Analyzer</p>
<ul>
<li>SimpleAnalyzer  简单分词器 </li>
<li>WhiteSpaceAnalyzer  空格分词器  </li>
<li>StandardAnalyzer  标准分词器  </li>
<li>StopAnalyzer    停用词  </li>
</ul>
<p>TokenStream是一个很重要的方法 </p>
<p>“how are you thank you”这一个输入的字符串传入到分词器转换成—&gt;TokenStream 分词的一个流,里面保存着所有的分词信息  </p>
<p>TokenStream有2个实现类 </p>
<p>一个是Tokenizer :将一组数据划分为不同的语汇单元 (一个一个的单词,还会转化成小写)</p>
<p>一个是TokenFilter: </p>
<p><img src="56.png" alt></p>
<p><img src="55.png" alt> </p>
<p><img src="57.png" alt> </p>
<p><img src="58.png" alt> </p>
<h1 id="通过TokenStream显示分词"><a href="#通过TokenStream显示分词" class="headerlink" title="通过TokenStream显示分词"></a>通过TokenStream显示分词</h1><pre><code class="Java">    /**
     * 通过字符串和分词器来把分词信息输出出来
     * @param str
     * @param analyzer
     */
    public static void displayToken(String str, Analyzer analyzer) throws IOException {
       TokenStream tokenStream= analyzer.tokenStream(&quot;content&quot;,new StringReader(str));//第一个参数fieldName,我们这个例子里没意义，随便填 ,第二个参数Reader,我们这里是StringReader
        //创建一个属性，这个属性会添加到Stream中
        CharTermAttribute charTermAttribute=tokenStream.addAttribute(CharTermAttribute.class);//tokenStream相当于水流，CharTermAttribute相当于水杯，水杯丢进水流  CharTermAttribute用来装词汇的
        while (tokenStream.incrementToken()){//类似于迭代器  只要水杯不空
            System.out.print(&quot;[&quot;+charTermAttribute+&quot;]&quot;);
        }
        System.out.println();//换行
        System.out.println(&quot;-----------------------------------&quot;);

    }
</code></pre>
<pre><code class="Java">    @Test
    public void testAnalyzer() throws IOException {
        Analyzer a1=new StandardAnalyzer(Version.LUCENE_35);
        Analyzer a2=new StopAnalyzer(Version.LUCENE_35);
        Analyzer a3=new SimpleAnalyzer(Version.LUCENE_35);
        Analyzer a4=new WhitespaceAnalyzer(Version.LUCENE_35);
        String txt=&quot;this is my house,i am  come from zhejiang shaoxing&quot;;
        AnalyzerUtil.displayToken(txt,a1);
        AnalyzerUtil.displayToken(txt,a2);
        AnalyzerUtil.displayToken(txt,a3);
        AnalyzerUtil.displayToken(txt,a4);
    }
</code></pre>
<p>结果   </p>
<p><img src="59.png" alt></p>
<p>StopAnalyzer停用词，把this is 给停用掉了  </p>
<p>SimpleAnalyzer是LetterTokenizer标点符号分词</p>
<p>WhitespaceAnalyzer是空格分词，以至于把<code>house,i</code>分在了一起 </p>
<pre><code>[my][house][i][am][come][from][zhejiang][shaoxing]
-----------------------------------
[my][house][i][am][come][from][zhejiang][shaoxing]
-----------------------------------
[this][is][my][house][i][am][come][from][zhejiang][shaoxing]
-----------------------------------
[this][is][my][house,i][am][come][from][zhejiang][shaoxing]
</code></pre><p>把txt改为</p>
<blockquote>
<p>String txt=”this is my house,i am  come from zhejiang shaoxing.My email is lucene@gmail.com.My QQ is 123456”;</p>
</blockquote>
<p>结果为</p>
<pre><code>[my][house][i][am][come][from][zhejiang][shaoxing.my][email][lucene][gmail.com.my][qq][123456]
-----------------------------------
[my][house][i][am][come][from][zhejiang][shaoxing][my][email][lucene][gmail][com][my][qq]
-----------------------------------
[this][is][my][house][i][am][come][from][zhejiang][shaoxing][my][email][is][lucene][gmail][com][my][qq][is]
-----------------------------------
[this][is][my][house,i][am][come][from][zhejiang][shaoxing.My][email][is][lucene@gmail.com.My][QQ][is][123456]
</code></pre><p>可以看到第一个标准分词器，数字有，邮箱对  </p>
<p>第二个停用词分词器把数字给停用了 ,邮箱也不对,成了2个词 </p>
<p>简单分词器数字没了  </p>
<p>接下来我们测中文  </p>
<blockquote>
<p>String txt=”我来自绍兴”;  </p>
</blockquote>
<p>结果 </p>
<pre><code>[我][来][自][绍][兴]
-----------------------------------
[我来自绍兴]
-----------------------------------
[我来自绍兴]
-----------------------------------
[我来自绍兴]
</code></pre><p>只有标准分词器是一个个拆开的，其他都在一起  </p>
<p>所以以上分词器对于中文分词全部不适用  </p>
<p>总结： 一个字符串由分词器来分词会产生一个TokenStream的流，里面存了大量的属性，可以通过<code>CharTermAttribute</code>来获取流里面的分词信息，所以我们获取流，然后把<code>CharTermAttribute</code>放进去</p>
<p>如何查看Stream里的偏移量和位置增量？下节课介绍   </p>
<h1 id="通过TokenStream显示分词的详细信息"><a href="#通过TokenStream显示分词的详细信息" class="headerlink" title="通过TokenStream显示分词的详细信息"></a>通过TokenStream显示分词的详细信息</h1><pre><code class="Java">    public static  void displayAllTokenInfo(String str,Analyzer analyzer) throws IOException {
        TokenStream tokenStream=analyzer.tokenStream(&quot;content&quot;,new StringReader(str));
        PositionIncrementAttribute positionIncrementAttribute=tokenStream.addAttribute(PositionIncrementAttribute.class);
        OffsetAttribute offsetAttribute=tokenStream.addAttribute(OffsetAttribute.class);
        CharTermAttribute charTermAttribute=tokenStream.addAttribute(CharTermAttribute.class);
        TypeAttribute typeAttribute=tokenStream.addAttribute(TypeAttribute.class);
        for(;tokenStream.incrementToken();){
            System.out.print(&quot;位置增量:&quot;+positionIncrementAttribute.getPositionIncrement());
            System.out.print(&quot;单词信息:&quot;+charTermAttribute+&quot;[&quot;+offsetAttribute.startOffset()+&quot;,&quot;+offsetAttribute.endOffset()+&quot;]&quot;);
            System.out.print(&quot;类型:&quot;+typeAttribute.type());
            System.out.println();//换行;
        }
    }
</code></pre>
<pre><code class="Java">    @Test
    public  void testDisplayAllTokenInfo() throws IOException {
        Analyzer a1=new StandardAnalyzer(Version.LUCENE_35);
        Analyzer a2=new StopAnalyzer(Version.LUCENE_35);
        Analyzer a3=new SimpleAnalyzer(Version.LUCENE_35);
        Analyzer a4=new WhitespaceAnalyzer(Version.LUCENE_35);
        String txt=&quot;how are you thank you&quot;;
        AnalyzerUtil.displayAllTokenInfo(txt,a1);
        System.out.println(&quot;-------------------&quot;);
        AnalyzerUtil.displayAllTokenInfo(txt,a2);
        System.out.println(&quot;-------------------&quot;);
        AnalyzerUtil.displayAllTokenInfo(txt,a3);
        System.out.println(&quot;-------------------&quot;);
        AnalyzerUtil.displayAllTokenInfo(txt,a4);
    }
</code></pre>
<p>结果: </p>
<pre><code>标准分词器
位置增量:1单词信息:how[0,3]类型:&lt;ALPHANUM&gt;
位置增量:2单词信息:you[8,11]类型:&lt;ALPHANUM&gt; 位置增量2  跳过了一个单词 are
位置增量:1单词信息:thank[12,17]类型:&lt;ALPHANUM&gt;
位置增量:1单词信息:you[18,21]类型:&lt;ALPHANUM&gt;
-------------------
停用词分词器
位置增量:1单词信息:how[0,3]类型:word
位置增量:2单词信息:you[8,11]类型:word    位置增量2  跳过了一个单词 are
位置增量:1单词信息:thank[12,17]类型:word
位置增量:1单词信息:you[18,21]类型:word
-------------------
简单分词器
位置增量:1单词信息:how[0,3]类型:word
位置增量:1单词信息:are[4,7]类型:word
位置增量:1单词信息:you[8,11]类型:word
位置增量:1单词信息:thank[12,17]类型:word
位置增量:1单词信息:you[18,21]类型:word
-------------------
空格分词器
位置增量:1单词信息:how[0,3]类型:word
位置增量:1单词信息:are[4,7]类型:word
位置增量:1单词信息:you[8,11]类型:word
位置增量:1单词信息:thank[12,17]类型:word
位置增量:1单词信息:you[18,21]类型:word
</code></pre><p>PositionIncrementAttribute 位置增量  元素与元素之间的相隔多少词语 </p>
<p>OffsetAttribute 偏移量</p>
<p>CharTermAttribute 每一个分词的元素</p>
<p>TypeAttribute 这一个分词的类型 </p>
<p>TokenStream分词器做好处理之后得到的一个流，这个流中存储了分词的各种信息，可以通过TokenStream有效的获取到分词单元 </p>
<p>Tokenizer主要负责接收字符流Reader,将Reader进行分词操作,有如下实现类</p>
<p><img src="55.png" alt> </p>
<p>TokenFilter将各种各样的语汇单元进行过滤 </p>
<h1 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器</h1><pre><code class="Java">public final class MyStopAnalyzer extends Analyzer{
    private Set stops;
    public MyStopAnalyzer(String[] stopword){
        stops= StopFilter.makeStopSet(Version.LUCENE_35,stopword,true);//第三个参数:是否忽略大小写
    }
    public TokenStream tokenStream(String s, Reader reader) {
        return new StopFilter(//Filter链
                Version.LUCENE_35,
                new LowerCaseFilter(Version.LUCENE_35,
                        new LetterTokenizer(Version.LUCENE_35,reader)
                ),
        stops);

    }
}
</code></pre>
<pre><code class="Java">    @Test
    public void testMyStopTokenizer() throws IOException {
        Analyzer myStopAnalyzer=new MyStopAnalyzer(new String[]{&quot;i&quot;,&quot;you&quot;});
        String txt=&quot;how are you thank you&quot;;
        AnalyzerUtil.displayToken(txt,myStopAnalyzer);
    }
</code></pre>
<p>结果 </p>
<p><code>[how][are][thank]</code> 但是默认的StopAnalyzer are是过滤掉的。说明自定义之后原本默认的过滤词没有了 </p>
<p>接下来我们加入原来默认的过滤词 </p>
<p>通过<code>System.out.println(StopAnalyzer.ENGLISH_STOP_WORDS_SET);</code>可以获取到原来有哪些停用词 </p>
<p><code>[but, be, with, such, then, for, no, will, not, are, and, their, if, this, on, into, a, or, there, in, that, they, was, is, it, an, the, as, at, these, by, to, of]</code>  </p>
<p>现在我们把它们加上</p>
<pre><code class="Java">public final class MyStopAnalyzer extends Analyzer{
    private Set stops;
    public MyStopAnalyzer(String[] stopword){
        System.out.println(StopAnalyzer.ENGLISH_STOP_WORDS_SET);
        stops= StopFilter.makeStopSet(Version.LUCENE_35,stopword,true);//第三个参数:是否忽略大小写
        stops.addAll(StopAnalyzer.ENGLISH_STOP_WORDS_SET);//加上原来默认的停用词
    }
    public TokenStream tokenStream(String s, Reader reader) {
        return new StopFilter(//Filter链
                Version.LUCENE_35,
                new LowerCaseFilter(Version.LUCENE_35,
                        new LetterTokenizer(Version.LUCENE_35,reader)
                ),
        stops);

    }
}
</code></pre>
<p>这样结果就变为了 </p>
<p><code>[how][thank]</code> </p>
<h1 id="中文分词介绍"><a href="#中文分词介绍" class="headerlink" title="中文分词介绍"></a>中文分词介绍</h1><p>庖丁解牛分词器 —已经停止更新了 </p>
<p>mmseg:使用搜狗的词库</p>
<p><a href="https://github.com/chenlb/mmseg4j-from-googlecode" target="_blank" rel="noopener">Mmseg github</a> </p>
<p>pom中加入下面的引用 </p>
<pre><code class="Xml">    &lt;dependency&gt;
      &lt;groupId&gt;com.chenlb.mmseg4j&lt;/groupId&gt;
      &lt;artifactId&gt;mmseg4j-dic&lt;/artifactId&gt;
      &lt;version&gt;1.8.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.chenlb.mmseg4j&lt;/groupId&gt;
      &lt;artifactId&gt;mmseg4j-analysis&lt;/artifactId&gt;
      &lt;version&gt;1.8.6&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>上一节的例子加入mmseg的Analyzer </p>
<pre><code class="Java">    @Test
    public void testAnalyzer02() throws IOException {
        Analyzer a1=new StandardAnalyzer(Version.LUCENE_35);
        Analyzer a2=new StopAnalyzer(Version.LUCENE_35);
        Analyzer a3=new SimpleAnalyzer(Version.LUCENE_35);
        Analyzer a4=new WhitespaceAnalyzer(Version.LUCENE_35);
        Analyzer a5=new MMSegAnalyzer();
        //Analyzer a6=new MMSegAnalyzer();
        String txt=&quot;我来自绍兴,我爱喝女儿红&quot;;
        AnalyzerUtil.displayToken(txt,a1);
        AnalyzerUtil.displayToken(txt,a2);
        AnalyzerUtil.displayToken(txt,a3);
        AnalyzerUtil.displayToken(txt,a4);
        AnalyzerUtil.displayToken(txt,a5);
    }
</code></pre>
<p>结果 </p>
<p><img src="60.png" alt> </p>
<h1 id="实现自定义同义词分词器"><a href="#实现自定义同义词分词器" class="headerlink" title="实现自定义同义词分词器"></a>实现自定义同义词分词器</h1><h1 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h1>
        
                <blockquote style="margin: 2em 0 0;padding: 0.5em 1em;border-left: 3px solid #F44336;background-color: #F5F5F5;list-style: none;">
                    <p><strong>
                         
                            This blog is under a CC BY-NC-SA 3.0 Unported License
                        </strong>
                        <br>
                        <strong>本文链接：</strong><a href="http://hogwartsrico.github.io/2017/10/01/Introduction-of-Lucene/">http://hogwartsrico.github.io/2017/10/01/Introduction-of-Lucene/</a>
                    </p>
                </blockquote>
        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2018/09/01/proxy-in-Spring/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2017/09/22/Introduction-of-ElasticSearch/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="Rico's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        chenhongjie101@gmail.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2020/06/">六月 2020<span class="sidebar_archives-count">12</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/10/">十月 2019<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/09/">九月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/05/">五月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/03/">三月 2019<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/02/">二月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/01/">一月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/12/">十二月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/11/">十一月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/09/">九月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/10/">十月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/09/">九月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/08/">八月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/04/">四月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/03/">三月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/09/">九月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/07/">七月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/03/">三月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/02/">二月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/04/">四月 2015<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/01/">一月 2015<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/Ricoccc" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/rico.austin.5" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://plus.google.com/u/0/103668464393164710629" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    
        <a href="https://weibo.com/1878017080/profile" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-weibo">
                <span class="visuallyhidden">Weibo</span>
            </button><!--
     --></a>
    

    <!-- Instagram -->
    
        <a href="https://www.instagram.com/hogwartsrico/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-instagram">
                <span class="visuallyhidden">Instagram</span>
            </button><!--
     --></a>
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/HogwartsRico" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    
        <a href="https://space.bilibili.com/14573494" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-bilibili">
                <span class="visuallyhidden">Bilibili</span>
            </button><!--
     --></a>
    

    <!-- Telegram -->
    

    <!-- V2EX -->
    
        <a href="https://v2ex.com/member/Rico" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-v2ex">
                <span class="visuallyhidden">V2EX</span>
            </button><!--
     --></a>
    

    <!-- Segmentfault -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;<span year></span>&nbsp;Rico's Blog
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>-->
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?Bn9UzEm8RrBSxqyZB0zPjA==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>



    
        <script>lsloader.load("sm_js","/js/smoothscroll.js?lOy/ACj5suSNi7ZVFVbpFQ==", true)</script>
    











<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->

<script type="text/ls-javascript" id="Bing-Background-script">
    queue.offer(function(){
        $('body').attr('data-original', 'https://api.i-meto.com/bing?');
    });
</script>


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    var copyrightNow = new Date().getFullYear();
    var textContent = document.querySelector('span[year]')

    copyrightSince = 2014;
    if (copyrightSince === copyrightNow||copyrightSince === 0000) {
        textContent.textContent = copyrightNow
    } else {
        textContent.textContent = copyrightSince + ' - ' + copyrightNow
    }

    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.6 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
